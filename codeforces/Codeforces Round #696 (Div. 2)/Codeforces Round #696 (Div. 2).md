# Codeforces Round #696 (Div. 2)

## A. Puzzle From the Future

### 문제 설명

2022년에, Mike는 앞에 0이 올 수 있는, 길이가 n인 binary integer a와 b를 발견했다(둘 모두 오직 숫자 0과 1로만 쓰여있다). 그들을 잊지 않기 위해, 그는 다음과 같은 방방법으로 integer d를 만들고자 한다.

- 그는 a와 b의 비트 합의 결과로 integer c를 만들었다. 그래서 c는 하나 또는 그 이상의 2-s를 가질 수 있다. 예를 들어, 0110과 1101의 비트합은 1211이고 011000과 011000의 합은 022000이다.
- 그 후 Mike는 c의 같은 연속된 숫자를 한 자리 수로 대체하고 d를 얻는다. 위 경우에서 이 과정을 거치면 1211은 121이되고 022000은 020이 된다(따라서 d는 동등한 연속된 숫자를 가질 수 없다).

불행하게도, Mike는 그가 d를 계산하기 전에 integer a를 잃어버렸다. 이제 그를 격려하기 위해, 당신은 d가 integer로써 최대가 될 수 있는 길이가 n인 임의의 binary integer a를 찾고자 한다.

정수로써 가능한 최대는 102 > 21, 012 < 101, 021 = 21, 기타 등등... 을 의미한다.

### Input

첫번째 줄은 single integer t를 포함한다. (1 <= t <= 1000) - 테스트 케이스의 수

각 테스트 케이스의 첫 번째 줄은 integer n을 포함한다. (1 <= n <= 10^5) - a와 b의 길이

각 테스트 케이스의 두 번째 줄은 길이가 n인 binary integer b를 포함한다. integer b는 숫자 0과 1로만 구성되어 있다.

전체 t개의 테스트 케이스들에서 n의 총 합계는 10^5를 초과하지 않는다.

### Output

각 테스트 케이스에서 길이가 n인 binary integer a 하나를 출력하라. a또는 b는 앞에 0을 가질지도 모르나 반드시 동일한 길이 n을 가져야 한다는 것을 알아둬야 한다.



## B. Different Divisiors

### 문제 설명

만약 y를 나머지 없이 x로 나눌 수 있다면, 양의 정수 x는 양의 정수 y의 divisor로 불린다. 예를 들어, 1은 7의 divisor이고 3은 8의 divisor가 아니다. 

우리는 당신에게 정수 d를 주고 다음을 만족하는 가장 작은 양의 정수 a를 물어볼것이다.

- a는 적어도 4개의 divisor를 가지고 있다.
- 임의의 두 divisor의 차이는 적어도 d이다.

### Input

첫번째 줄은 하나의 정수 t를 포함한다. (1 <= t <= 3000) - 테스크 케이스의 수

각 테스트 케이스의 첫번째 줄은 하나의 정수 d를 포함한다. (1 <= d <=10000)

### Ouptut

각 테스트 케이스는 하나의 양의 정수 a를 출력한다. - 해당 테스트 케이스의 답



## C. Array Destruction

### 문제 설명

당신은 2n개 양의 정수를 가진 쓸모없는 배열 a를 찾았다. 당신은 이 배열이 필요 없다는 것을 깨달았기 때문에 a의 모든 원소를 제거하기로 했다.

그것은 쉬운 작업이 될 수 있으나, 당신은 몇 가지의 규칙을 따라야 한다는 것을 알았다.

1. 시작할 때, 당신은 임의의 양의 정수 x를 고른다.
2. 그리고 당신은 다음과 같은 동작을 n회 해야한다.
   - 합이 x와 동일한 배열의 두 원소를 선택
   - 두 원소를 a로부터 제거하고 x를 두 숫자중에 큰 숫자로 대체

예를 들어, 만약 a = [3, 5, 1, 2]가 있다면, 당신은 6을 선택할 수 있다. 그리고 당신은 a의 2, 3번째 원소를 고를 수 있고 그들을 제거한다. 이 작업 후에, x는 5와 같고 배열엔 두 원소 3과 2가 있다. 당신은 다음 작업에 그들을 제거할 수 있다.

당신은 x를 시작 저에 골라야 하고 작업 도중에 바꿀 수 없다는 것을 알아둬야 한다.

a의 모든 원소를 제거하기 위해 어떻게 행동해야 할지를 판별하라.

### Input

첫 번째 줄은 하나의 정수 t를 포함한다. (1 <= t <= 1000) - 테스트 케이스의 수

각 테스트 케이스의 첫 번째 줄은 하나의 정수 n을 포함한다.(1 <= n <= 1000).

각 테스트 케이스의 두 번째 줄은 배열 a의 2n개의 양의 정수들을 포함한다.

모든 테스트 케이스에서 n의 총 합은 1000을 초과하지 않는 것이 보장된다.

### Output

각 테스트 케이스의 첫번째 줄은, 만약 모든 원소를 제거할 수 있다면 YES를 출력하고 그렇지 않다면 NO를 출력한다.

모든 원소를 제거할 수 있다면 당신이 고른 x의 첫 값을 출력하라. 그 다음 n번의 동작의 설명을 출력하라. 각 동작에서, 당신이 제거한 정수의 짝을 출력하라.



## D. Cleaning

### 문제 설명

해안을 청소하는 동안, Alice는 n개의 돌더미를 발견했다. i번째 더미는 a_i개의 돌을 가지고 있다.

더미 i와 i+1은 모든 1 <= i <= n-1 에 대해 이웃하고 있다. 만약 pile i가 비게 된다면, 더미 i-1과 i+1은 이웃하지 않게 된다.

Alice는 이 돌들을 제거하기에는 너무 게을러서 당신이 이 의무를 맡도록 했다. 그녀는 당신이 오직 다음과 같은 동작만 하는 것을 허가했다.

- 두 개의 이웃하는 더미를 선택하고, 만약 둘 다 비어있지 않다면 둘에서 각각 돌 하나를 제거한다.

Alice는 가끔은 주어진 동작으로는 모든 돌더미를 제거할 수 없다는 것을 이해했기 때문에 당신에게 다음과 같은 초능력을 허락했다.

- 청소를 시작하기 전에, 당신은 두 개의 이웃하는 더미를 선택하고 둘을 바꿀 수 있다.

초능력을 1회보다 더 사용하지 않고 모든 돌을 제거할 수 있는지 판별하라.

### Input

첫 번째 줄은 하나의 정수 t를 포함한다. (1 <= t <= 10^4) - 테스트 케이스의 수

각 테스트 케이스의 첫 번째 줄은 하나의 정수 n을 포함한다. (2 <= n <= 2*10^5) - 돌더미의 수

각 테스트 케이스의 두 번째 줄은 n개의 정수 a1, a2 , ... , an을 포함한다. - 각 더미의 돌 개수

모든 테스트 케이스에서 n의 총 합은 2*10^5를 넘지 않는다.

### Output

각 테스트 케이스에서 YES 또는 NO를 출력하라. - 초능력을 한 번 보다 더 사용하지 않고 모든 돌을 제거할 수 있는지

